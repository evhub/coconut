from .util import *  # type: ignore
from .util import __doc__ as util_doc
from .util import operator

from .util import operator <$
from .util import operator !!
from .util import operator ***
from .util import :operator ?int
from .util import operator CONST
from .util import operator “
from .util import operator ”
from .util import operator !

operator lol
operator ++
from .util import (
    (lol),
    plus1 as (++),
)

def suite_test() -> bool:
    """Executes the main test suite."""
    assert 1 `plus` 1 == 2 == 1 `(+)` 1
    assert "1" `plus` "1" == "11" == "1" `(+)` "1"
    assert 3 `mod` 6 == 3 == 3 `(%)` 6
    assert 5 `mod` 4 == 1 == 5 `mod_` 4
    assert 5 `mod` 2 `plus` 2 == 3 == 5 `(%)` 2 `(+)` 2
    assert "11" `base` 2 == 3
    assert "10A" `int` 12 == 154
    assert ["1", "2"] `join_with` ", " == "1, 2"
    assert ["a","b","c"] `join_with` == "abc"
    assert {"a", 5} |> len == 2
    assert 5 |> swap2((-))$(2) |> (*)$(2) == 6 == 5 |> swap2_((-))$(2) |> (*)$(2)
    assert all(same((1, 2, 3), [1, 2, 3]))
    assert chain2((|1, 2|), (|3, 4|)) |> list == [1, 2, 3, 4]
    assert threeple$(1, 2)(3) == (1, 2, 3)
    assert 1 `range` 5 |> product == 24 == 1 `range` 5 |> product_
    assert plus1(4) == 5 == plus1_(4)  # type: ignore
    assert 2 `plus1` == 3 == plus1(2)
    assert plus1(plus1(5)) == 7 == (plus1..plus1)(5)
    assert `plus1..plus1` 5 == 7 == plus1 (plus1 5)
    assert `sqrt` 16 == 4 == `sqrt_` 16
    assert `square` 3 == 9
    def test_sqplus1_plus1sq(sqplus1, plus1sq, parallel=True):
        assert sqplus1(3) == 10 == (plus1..square)(3), sqplus1
        if parallel:
            assert parallel_map(sqplus1, range(3)) |> tuple == (1, 2, 5), sqplus1  # type: ignore
        assert 3 `plus1sq` == 16, plus1sq
        assert 3 `sqplus1` == 10, sqplus1
    test_sqplus1_plus1sq(sqplus1_1, plus1sq_1)
    test_sqplus1_plus1sq(sqplus1_2, plus1sq_2, parallel=False)
    with parallel_map.multiple_sequential_calls(max_workers=2):  # type: ignore
        test_sqplus1_plus1sq(sqplus1_3, plus1sq_3)
        test_sqplus1_plus1sq(sqplus1_4, plus1sq_4)
        test_sqplus1_plus1sq(sqplus1_5, plus1sq_5)
    assert 3 |> plus1 |> square == 16 == 3 |> plus1_ |> square  # type: ignore
    assert reduce((|>), [3, plus1, square]) == 16 == pipe(pipe(3, plus1), square)  # type: ignore
    assert reduce((..), [sqrt, square, plus1])(3) == 4 == compose(compose(sqrt, square), plus1)(3)  # type: ignore
    assert sum_([1,7,3,5]) == 16
    assert add([1,2,3], [10,20,30]) |> list == [11,22,33]
    assert add_([1,2,3], [10,20,30]) |> list == [11,22,33]
    assert zipsum([1,2,3], [10,20,30]) |> list == [11,22,33]  # type: ignore
    assert clean("   ab cd ef   ") == "ab cd ef" == "   ab cd ef   " |> clean
    assert add2 <| 2 <| 3 == 5
    qsorts = [qsort1, qsort2, qsort3, qsort4, qsort5, qsort6, qsort7, qsort8]
    for qsort in qsorts:
        to_sort = rand_list(10)
        assert to_sort |> qsort |> tuple == to_sort |> sorted |> tuple, qsort  # type: ignore
    to_sort = rand_list(10)
    assert parallel_map(tuple <.. (|>)$(to_sort), qsorts) |> list == [to_sort |> sorted |> tuple] * len(qsorts)
    assert repeat(3)$[2] == 3 == repeat_(3)$[2]
    assert sum_(repeat(1)$[:5]) == 5 == sum_(repeat_(1)$[:5])
    assert (sum_(takewhile((x)-> x<5, N()))
            == 10
            == dropwhile((>)$(0), (range(-10, 0) :: N()))$[:5] |> sum
            )
    assert "ABCDEFG" |> ((s) -> map(s[], (1, 3, 5))) |> sum_ == "BDF"  # type: ignore
    assert N()$[10:15] |> list == [10,11,12,13,14] == N_()$[10:15] |> list
    assert (N() |> takewhile$((>)$(5)) |> list
            == [0,1,2,3,4]
            == range(0,10)$[:5:] |> list
            )
    assert (range(-10, 0) :: N())$[5:15] |> sum == -5 == chain(range(-10, 0), N())$[5:15] |> sum
    assert add(repeat(1), N())$[:5] |> list == [1,2,3,4,5] == add_(repeat(1), N_())$[:5] |> list
    assert sum(N()$[5:]$[:5]) == 35 == sum(N_()$[5:]$[:5])
    assert N()$[](slice(5, 10)) |> list == [5,6,7,8,9] == list(range(0, 15))[](slice(5, 10))  # type: ignore
    assert N()$[slice(5, 10)] |> list == [5,6,7,8,9] == list(range(0, 15))[slice(5, 10)]
    assert preN(range(-5, 0))$[1:10] |> list == [-4,-3,-2,-1,0,1,2,3,4]
    assert map_iter((*)$(2), N())$[:5] |> list == [0,2,4,6,8]
    assert N()$[:100] |> tuple == N_()$[:100] |> tuple == N__()$[:100] |> tuple
    assert 12 |> next_mul_of $(5) == 15
    assert collatz(27)
    assert preop(1, 2).add() == 3
    assert vector(3, 4) |> abs == 5 == vector_with_id(3, 4, 1) |> abs
    assert vector(1, 2) |> ((v) -> map(v., ("x", "y"))) |> tuple == (1, 2)  # type: ignore
    assert vector(3, 1) |> vector(1, 2).transform |> ((v) -> map(v[], (0, 1))) |> tuple == (4, 3)  # type: ignore
    assert vector(1, 2) |> vector(1, 2).__eq__
    assert not vector(1, 2) |> vector(3, 4).__eq__
    assert not (1, 2) |> vector(1, 2).__eq__
    assert vector(vector(4, 3)) == vector(4, 3)
    assert not vector(4, 3) != vector(4, 3)
    assert not vector(1, 2) == (1, 2)
    assert not vector(2, 3) != vector(2, 3)
    assert vector(1, 2) != (1, 2)
    assert vector(1, 2) + vector(2, 3) == vector(3, 5)
    assert vector(1, 2) + 1 == vector(2, 3) == 1 + vector(1, 2)
    assert triangle(3, 4, 5).is_right()
    assert (.)(triangle(3, 4, 5), "is_right")
    assert (.is_right())(triangle(3, 4, 5))
    assert triangle(3, 4, 5) |> .is_right()
    def test_factorial(factorial, test_none=True):
        assert factorial(0) == 1 == factorial(1)
        assert factorial(3) == 6
        if test_none:
            assert factorial(-1) is None
    test_factorial(factorial1)
    test_factorial(factorial2)
    test_factorial(factorial4)
    test_factorial(factorial5)
    test_factorial(fact, test_none=False)
    test_factorial(fact_, test_none=False)
    test_factorial(factorial, test_none=False)
    assert factorial3([2,3]) == [2,6] == factorial3((2,3))
    assert classify(()) == "empty tuple"
    assert classify([]) == "empty list"
    assert classify((1,)) == "singleton tuple"
    assert classify([1,1]) == "duplicate pair list of 1"
    assert classify((1,2)) == "pair tuple"
    assert classify([1,2,3]) == "list"
    assert classify((1,1,1)) == "tuple"
    assert classify({}) == "empty dict"
    assert classify({"a":1}) == "dict"
    assert classify({0}) == "set of 0" == classify(f{0})
    assert classify({0,1}) == "set" == classify(f{1})
    assert classify(s{}) == "empty set" == classify(f{})
    assert classify_sequence(()) == "empty"
    assert classify_sequence((1,)) == "singleton"
    assert classify_sequence((1, 1)) == "duplicate pair of 1"
    assert classify_sequence((1, 2)) == "pair"
    assert classify_sequence((1, 2, 3)) == "few"
    assert dictpoint({"x":1, "y":2}) == (1,2)
    assert dictpoint_({"x":1, "y":2}) == (1,2) == dictpoint__({"x":1, "y":2})
    assert map_((+)$(1), []) == []
    assert map_((+)$(1), ()) == ()
    assert map_((+)$(1), [0,1,2,3]) == [1,2,3,4]
    assert map_((+)$(1), (0,1,2,3)) == (1,2,3,4)
    assert duplicate_first1([1,2,3]) == [1,1,2,3] == duplicate_first2([1,2,3]) |> list
    assert one_to_five([1,2,3,4,5]) == [2,3,4]
    assert not one_to_five([0,1,2,3,4,5])
    assert one_to_five([1,5]) == []
    assert -4 == neg_square_u(2) ≠ 4 ∧ 0 ≤ neg_square_u(0) ≤ 0
    assert is_null(null1())
    assert is_null(null2())
    assert empty() |> depth_1 == 0 == empty() |> depth_2
    assert leaf(5) |> depth_1 == 1 == leaf(5) |> depth_2
    assert node(leaf(2), node(empty(), leaf(3))) |> depth_1 == 3 == node(leaf(2), node(empty(), leaf(3))) |> depth_2
    assert maybes(5, square, plus1) == 26
    assert maybes(None, square, plus1) is None
    assert square <| 2 == 4
    assert (5, 3) |*> mod == 2 == mod <*| (5, 3)
    assert Just(5) <| square <| plus1 == Just(26)  # type: ignore
    assert Nothing() <| square <| plus1 == Nothing()  # type: ignore
    assert not Nothing() == ()
    assert not () == Nothing()
    assert not Nothing() != Nothing()
    assert Nothing() != ()
    assert () != Nothing()
    assert not Just(1) == (1,)
    assert not (1,) == Just(1)
    assert not Just(1) != Just(1)
    assert Just(1) != (1,)
    assert (1,) != Just(1)
    assert head_tail([1,2,3]) == (1, [2,3])
    assert init_last([1,2,3]) == ([1,2], 3)
    assert last_two([1,2,3]) == (2, 3) == last_two_([1,2,3])
    assert expl_ident(5) == 5 == ident(5)
    assert mod$ <| 5 <| 3 == 2 == (%)$ <| 5 <| 3
    assert 5 |> dectest == 5
    try:
        raise ValueError()
    except TypeError, ValueError as err:
        assert err
    else:
        assert False
    assert delist2([1, 2]) == (1, 2) == delist2_([1, 2])
    assert tuple1(1) == (1,) == tuple1_(1)
    assert tuple2(1, 2) == (1, 2) == tuple2_(1, 2)
    assert htsplit([1,2,3]) == [1,[2,3]] == htsplit_([1,2,3])
    assert iadd(1, 2) == 3 == iadd_(1, 2)
    assert strmul("a", 3) == "aaa" == strmul_("a", 3)
    try:
        strmul("a", "b")
    except MatchError as err:
        assert err.pattern == "match def strmul(str() as a, int() as x):"
        assert err.value == ("a", "b")
    else:
        assert False
    laz = lazy()
    assert not laz.done
    lazl = laz.list()
    assert lazl$[:3] |> list == [1, 2, 3] == lazl$[:3] |> list
    assert not laz.done
    assert lazl |> list == [1, 2, 3, None]
    assert laz.done
    assert is_empty(iter(()))
    assert is_empty(())
    assert not is_empty([1])
    assert is_one(iter([1]))
    assert not is_one(iter(()))
    assert not is_one([])
    assert is_one([1])
    assert trilen(3, 4).h == 5 == datamaker(trilen)(5).h
    assert A().true() is True
    inh_a = inh_A()
    assert inh_a.true() is True
    assert inh_a.inh_true1() is True
    assert inh_a.inh_true2() is True
    assert inh_a.inh_true3() is True
    assert inh_a.inh_true4() is True
    assert inh_a.inh_true5() is True
    assert inh_A.inh_cls_true() is True
    assert pt.__doc__
    out0 = grid() |> grid_trim$(xmax=5, ymax=5)
    assert out0 == [
     [pt(x=0, y=0), pt(x=0, y=1), pt(x=0, y=2), pt(x=0, y=3), pt(x=0, y=4)],
     [pt(x=1, y=0), pt(x=1, y=1), pt(x=1, y=2), pt(x=1, y=3), pt(x=1, y=4)],
     [pt(x=2, y=0), pt(x=2, y=1), pt(x=2, y=2), pt(x=2, y=3), pt(x=2, y=4)],
     [pt(x=3, y=0), pt(x=3, y=1), pt(x=3, y=2), pt(x=3, y=3), pt(x=3, y=4)],
     [pt(x=4, y=0), pt(x=4, y=1), pt(x=4, y=2), pt(x=4, y=3), pt(x=4, y=4)]
    ]
    out1 = grid() |> grid_map$(abs) |> grid_trim$(xmax=5, ymax=5)
    out1_ = grid() |> grid_trim$(xmax=5, ymax=5) |> parallel_grid_map$(abs) |> map$(list) |> list
    assert out1[0] == [0.0, 1.0, 2.0, 3.0, 4.0] == out1_[0]
    assert out1[1][0] == 1.0 == out1_[1][0]
    assert out1[2][0] == 2.0 == out1_[2][0]
    assert out1[3][0] == 3.0 == out1_[3][0]
    assert out1[3][4] == 5.0 == out1_[3][4]
    assert out1[4][0] == 4.0 == out1_[4][0]
    assert out1[4][3] == 5.0 == out1_[4][3]
    x = 5
    x |>= square
    y = square
    y <|= 5
    assert x == 25 == y
    x = (5, 3)
    x |*>= mod
    y = mod
    y <*|= (5, 3)
    assert x == 2 == y
    x = square
    x ..= (+)$(1)
    x <|= 4
    assert x == 25
    v = vector(1, 2)
    try:
        v.x = 3  # type: ignore
    except AttributeError as err:
        assert err
    else:
        assert False
    try:
        v.new_attr = True  # type: ignore
    except AttributeError as err:
        assert err
    else:
        assert False
    assert SHOPeriodTerminate([-1, 0], 0, {"epsilon": 1})
    assert add_int_or_str_1(2) == 3 == coercive_add(2, "1")
    assert add_int_or_str_1("2") == "21" == coercive_add("2", 1)
    assert still_ident(3) == 3 == ident_(3)
    assert not_ident(3) == "bar"
    assert pattern_abs(4) == 4 == pattern_abs_(4)
    assert pattern_abs(0) == 0 == pattern_abs_(0)
    assert pattern_abs(-4) == 4 == pattern_abs_(-4)
    assert vector(1, 2) |> (==)$(vector(1, 2))
    assert vector(1, 2) |> .__eq__(other=vector(1, 2))  # type: ignore
    assert fibs()$[1:4] |> tuple == (1, 2, 3) == fibs_()$[1:4] |> tuple
    assert fibs() |> takewhile$((i) -> i < 4000000 ) |> filter$((i) -> i % 2 == 0 ) |> sum == 4613732 == fibs_() |> takewhile$((i) -> i < 4000000 ) |> filter$((i) -> i % 2 == 0 ) |> sum  # type: ignore
    assert loop([1,2])$[:4] |> list == [1, 2] * 2
    assert parallel_map(list .. .$[:2] .. loop, ([1], [2]))$[:2] |> tuple == ([1, 1], [2, 2])
    assert nest("a") |> .$[1] |> .$[1] |> .$[0] == "a"
    assert (def -> mod)()(5, 3) == 2
    assert sieve((2, 3, 4, 5)) |> list == [2, 3, 5]
    assert 11 == double_plus_one(5)
    assert 15 == assign_func_1((*), 3, 5)
    assert 15 == assign_func_2((*), 3, 5)
    assert 20 == (..)(minus$(2), mul$(2), plus$(1))(10)
    assert 20 == minus$(2) .. mul$(2) .. plus$(1) <| 10
    assert does_raise_exc(raise_exc)
    assert ret_none(10) is None
    assert (2, 3, 5) |*> ret_args_kwargs$(1, ?, ?, 4, ?, *(6, 7), a="k") == ((1, 2, 3, 4, 5, 6, 7), {"a": "k"})
    assert args_kwargs_func() is True
    assert int_func() == 0 == int_func(1)
    assert one_int_or_str(1) == 1
    assert one_int_or_str("a") == "a"
    assert x_is_int(4) == 4 == x_is_int(x=4)
    try:
        x_is_int(x="herp")
    except MatchError:
        pass
    else:
        assert False
    try:
        x_is_int()
    except MatchError:
        pass
    else:
        assert False
    assert x_as_y(x=2) == (2, 2) == x_as_y(y=2)
    assert x_y_are_int_gt_0(1, 2) == (1, 2) == x_y_are_int_gt_0(x=1, y=2)
    try:
        x_y_are_int_gt_0(1, y=0)
    except MatchError:
        pass
    else:
        assert False
    assert x_is_int_def_0() == 0 == x_is_int_def_0(x=0)
    try:
        x_is_int_def_0("derp")
    except MatchError:
        pass
    else:
        assert False
    assert head_tail_def_none() == (None, []) == head_tail_def_none([None])
    assert kwd_only_x_is_int_def_0() == 0 == kwd_only_x_is_int_def_0(x=0)
    try:
        kwd_only_x_is_int_def_0(1)
    except MatchError:
        pass
    else:
        assert False
    assert must_pass_x(1, x=2) == ((1,), 2), must_pass_x(1, x=2)
    try:
        must_pass_x(1, 2)
    except MatchError:
        pass
    else:
        assert False
    assert no_args_kwargs()
    try:
        no_args_kwargs(1)
    except MatchError:
        pass
    else:
        assert False
    try:
        no_args_kwargs(a=1)
    except MatchError:
        pass
    else:
        assert False
    a = altclass()
    assert a.func(1) == 1
    assert a.zero(10) == 0
    with Vars.using(globals()):
        assert var_one == 1  # type: ignore
    try:
        var_one  # type: ignore
    except NameError:
        pass
    else:
        assert False
    assert Just(3) |> map$(-> _*2) |*> Just == Just(6) == Just(3) |> fmap$(-> _*2)  # type: ignore
    assert Nothing() |> map$(-> _*2) |*> Nothing == Nothing() == Nothing() |> fmap$(-> _*2)  # type: ignore
    assert Elems(1, 2, 3) != Elems(1, 2)
    assert map(plus1, (1, 2, 3)) |> fmap$(times2) |> repr == map(times2..plus1, (1, 2, 3)) |> repr
    assert reversed((1, 2, 3)) |> fmap$(plus1) |> repr == map(plus1, (1, 2, 3)) |> reversed |> repr
    assert identity[1:2, 2:3] == (slice(1, 2), slice(2, 3))
    assert identity |> .[1:2, 2:3] == (slice(1, 2), slice(2, 3))
    assert (.[1:2, 2:3])(identity) == (slice(1, 2), slice(2, 3))
    assert identity.method(*(1,), **{"a": 2}) == ((1,), {"a": 2})
    assert (.method(*(1,), **{"a": 2}))(identity) == ((1,), {"a": 2})
    assert identity |> .method(*(1,), **{"a": 2}) == ((1,), {"a": 2})
    assert identity[1] == 1
    assert identity[1,] == (1,)
    assert identity |> .[0, 0] == (0, 0)

    assert container(1) == container(1)
    assert not container(1) != container(1)
    assert container(1) != container(2)
    assert not container(1) == container(2)

    assert container_(1) == container_(1)
    assert not container_(1) != container_(1)
    assert container_(1) != container_(2)
    assert not container_(1) == container_(2)

    t = Tuple_(1, 2)
    assert repr(t) == "Tuple_(*elems=(1, 2))"
    assert t.elems == (1, 2)
    assert isinstance(t.elems, tuple)
    assert t |> fmap$(-> _+1) == Tuple_(2, 3)  # type: ignore
    Tuple_(x, y) = t  # type: ignore
    assert x == 1 and y == 2
    p = Pred("name", 1, 2)
    p_ = Pred_("name", 1, 2)
    assert p.name == "name" == p_.name
    assert p.args == (1, 2) == p_.args
    assert repr(p) in ("Pred(name='name', *args=(1, 2))", "Pred(name=u'name', *args=(1, 2))")
    assert repr(p_) in ("Pred_(name='name', *args=(1, 2))", "Pred_(name=u'name', *args=(1, 2))")
    for Pred_test, p_test in [(Pred, p), (Pred_, p_)]:
        assert isinstance(p_test.args, tuple)  # type: ignore
        Pred_test(name, *args) = p_test  # type: ignore
        assert name == "name"
        assert args == (1, 2)
    q = Quant("name", "var", 1, 2)
    q_ = Quant_("name", "var", 1, 2)
    assert q.name == "name" == q_.name
    assert q.var == "var" == q_.var
    assert q.args == (1, 2) == q_.args
    assert repr(q) in ("Quant(name='name', var='var', *args=(1, 2))", "Quant(name=u'name', var=u'var', *args=(1, 2))")
    assert repr(q_) in ("Quant_(name='name', var='var', *args=(1, 2))", "Quant_(name=u'name', var=u'var', *args=(1, 2))")
    for Quant_test, q_test in [(Quant, q), (Quant_, q_)]:
        assert isinstance(q_test.args, tuple)  # type: ignore
        Quant_test(name, var, *args) = q_test  # type: ignore
        assert name == "name"
        assert var == "var"
        assert args == (1, 2)
    assert Pred(0, 1, 2) |> fmap$(-> _+1) == Pred(1, 2, 3)  # type: ignore
    assert Pred_(0, 1, 2) |> fmap$(-> _+1) == Pred_(1, 2, 3)  # type: ignore
    assert Quant(0, 1, 2) |> fmap$(-> _+1) == Quant(1, 2, 3)  # type: ignore
    assert Quant_(0, 1, 2) |> fmap$(-> _+1) == Quant_(1, 2, 3)  # type: ignore
    a = Nest()
    assert a.b.c.d == "data"
    assert a |> .b.c.d == "data" == (.b.c.d)(a)
    assert a.b.c.m() == "method"
    assert .b.c.m() <| a == "method" == (.b.c.m())(a)
    assert a |> .b.c ..> .m() == "method"
    assert a |> .b.c |> .m() == "method"
    assert a?.b?.c?.m?() == "method"
    assert a.b.c.none?.derp.herp is None  # type: ignore
    assert tco_chain([1, 2, 3]) |> list == ["last"]
    assert partition([1, 2, 3], 2) |> map$(tuple) |> list == [(1,), (3, 2)] == partition_([1, 2, 3], 2) |> map$(tuple) |> list
    assert myreduce((+), (1, 2, 3)) == 6
    assert recurse_n_times(10000)
    assert fake_recurse_n_times(10000)
    a = A()
    assert ((not)..a.true)() is False
    assert 10 % 4 % 3 == 2 == 10 `mod` 4 `mod` 3
    assert square_times2_plus1(3) == 19 == square_times2_plus1_(3)
    assert plus1_cube(2) == 27
    assert square ..> times2 ..> plus1 |> repr == square ..> (times2 ..> plus1) |> repr
    assert range(1, 5) |> map$(range) |> starmap$(toprint) |> tuple == ('0', '0 1', '0 1 2', '0 1 2 3')
    assert range(1, 5) |> map$(range) |> starmap$(toprint) |> fmap$(.strip(" 0")) |> tuple == ("", "1", "1 2", "1 2 3")
    assert () |> starmap$(toprint) |> len == 0  # type: ignore
    assert [(1, 2)] |> starmap$(toprint) |> .[0] == "1 2"  # type: ignore
    assert [(1, 2), (2, 3), (3, 4)] |> starmap$(toprint) |> .[1:] |> list == ["2 3", "3 4"]  # type: ignore
    assert none_to_ten() == 10 == any_to_ten(1, 2, 3)
    assert int_map(plus1_, range(5)) == [1, 2, 3, 4, 5]  # type: ignore
    assert still_ident.__doc__ == "docstring"
    assert still_ident.__name__ == "still_ident"
    with (
        context_produces(1) as one,
        context_produces(2) as two,
    ):
        assert one == 1
        assert two == 2
    with (context_produces(1)) as one:
        assert one == 1
    with context_produces((1, 2)) as (x, y):
        assert (x, y) == (1, 2)
    one_list = [0]
    with context_produces(1) as one_list[0]:
        assert one_list[0] == 1
    assert 1 ?? raise_exc() == 1
    try:
        assert None ?? raise_exc()
    except Exception as err:
        assert str(err) == "raise_exc"
    else:
        assert False
    for u, Point_test in [("", Point), ("_", Point_)]:
        p = Point_test()  # type: ignore
        assert p.x == 0 == p.y  # type: ignore
        assert repr(p) == "Point{u}(x=0, y=0)".format(u=u)
        p = Point_test(1)  # type: ignore
        assert p.x == 1  # type: ignore
        assert p.y == 0  # type: ignore
        assert repr(p) == "Point{u}(x=1, y=0)".format(u=u)
        p = Point_test(2, 3)  # type: ignore
        assert p.x == 2  # type: ignore
        assert p.y == 3  # type: ignore
        assert repr(p) == "Point{u}(x=2, y=3)".format(u=u)
    try:
        RadialVector()  # type: ignore
    except TypeError:
        try:
            RadialVector_()  # type: ignore
        except TypeError:
            pass
        else:
            assert False
    else:
        assert False
    rv = RadialVector(1)
    rv_ = RadialVector_(1)
    assert rv.mag == 1 == rv_.mag
    assert rv.angle == 0 == rv_.angle
    assert repr(rv) == "RadialVector(mag=1, angle=0)"
    assert repr(rv_) == "RadialVector_(mag=1, angle=0)"
    for u, ABC_test in [("", ABC), ("_", ABC_)]:
        try:
            ABC_test()  # type: ignore
        except TypeError:
            pass
        else:
            assert False
        abc = ABC_test(2)
        assert abc.a == 2  # type: ignore
        assert abc.b == 1  # type: ignore
        assert abc.c == ()  # type: ignore
        assert repr(abc) == "ABC{u}(a=2, b=1, *c=())".format(u=u)
        abc = ABC_test(3, 4, 5)
        assert abc.a == 3  # type: ignore
        assert abc.b == 4  # type: ignore
        assert abc.c == (5,)  # type: ignore
        assert repr(abc) == "ABC{u}(a=3, b=4, *c=(5,))".format(u=u)
        abc = ABC_test(5, 6, 7, 8)
        assert abc.a == 5  # type: ignore
        assert abc.b == 6  # type: ignore
        assert abc.c == (7, 8)  # type: ignore
        assert repr(abc) == "ABC{u}(a=5, b=6, *c=(7, 8))".format(u=u)
    tv = typed_vector(3, 4)
    assert repr(tv) == "typed_vector(x=3, y=4)"
    assert abs(tv) == 5
    try:
        tv.x = 2  # type: ignore
    except AttributeError:
        pass
    else:
        assert False
    tv = typed_vector()
    assert repr(tv) == "typed_vector(x=0, y=0)"
    for obj in (factorial, iadd, collatz, recurse_n_times):
        assert obj.__doc__ == "this is a docstring", obj
    assert list_type((|1,2|)) == "at least 2"
    assert list_type((|1|)) == "at least 1"
    assert list_type((| |)) == "empty"
    cnt = counter()
    cases cnt.inc():
        match 1:
            assert False
        match ():
            assert False
        match None:
            pass
    else:
        assert False
    assert cnt.count == 1
    assert plus1sq_all(1, 2, 3) |> list == [4, 9, 16] == plus1sq_all_(1, 2, 3) |> list  # type: ignore
    assert sqplus1_all(1, 2, 3) |> list == [2, 5, 10] == sqplus1_all_(1, 2, 3) |> list
    assert square_times2_plus1_all(1, 2) |> list == [3, 9] == square_times2_plus1_all_(1, 2) |> list  # type: ignore
    assert plus1_square_times2_all(1, 2) |> list == [8, 18] == plus1_square_times2_all_(1, 2) |> list
    assert plus1sqsum_all(1, 2) == 13 == plus1sqsum_all_(1, 2)  # type: ignore
    assert sum_list_range(10) == 45
    assert sum2([3, 4]) == 7
    assert ridiculously_recursive(300) == 201666561657114122540576123152528437944095370972927688812965354745141489205495516550423117825 == ridiculously_recursive_(300)
    assert [fib(n) for n in range(16)] == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] == [fib_(n) for n in range(16)]
    assert fib.cache_info().hits == 28
    fib_N = 100
    assert range(fib_N) |> map$(fib) |> .$[-1] == fibs()$[fib_N-2] == fib_(fib_N-1) == fibs_()$[fib_N-2]
    assert range(10*fib_N) |> map$(fib) |> consume$(keep_last=1) |> .$[-1] == fibs()$[10*fib_N-2] == fibs_()$[10*fib_N-2]
    assert (plus1 `(..)` x -> x*2)(4) == 9
    assert join_pairs1([(1, [2]), (1, [3])]).items() |> list == [(1, [2, 3])]  # type: ignore
    assert join_pairs2([(1, [2]), (1, [3])]).items() |> list == [(1, [3, 2])]
    assert return_in_loop(10)
    assert methtest().meth(5) == 5
    assert methtest().tail_call_meth(3) == 3
    def test_match_error_addpattern(int() as x):
        raise MatchError("pat", "val")
    @addpattern(test_match_error_addpattern)  # type: ignore
    def test_match_error_addpattern(x) = x
    try:
        test_match_error_addpattern(0)
    except MatchError as err:  # must not be caught inside addpattern
        assert err
    else:
        assert False

    assert dict(a=1, b=2) |**> ret_args_kwargs == ((), dict(a=1, b=2)) == (|**>)(dict(a=1, b=2), ret_args_kwargs)
    x = dict(a=1, b=2)
    x |**>= ret_args_kwargs
    assert x == ((), dict(a=1, b=2))

    assert ret_args_kwargs <**| {"a": 1, "b": 2} == ((), {"a": 1, "b": 2}) == (<**|)(ret_args_kwargs, {"a": 1, "b": 2})
    f = ret_args_kwargs
    f <**|= {"a": 1, "b": 2}
    assert f == ((), {"a": 1, "b": 2})

    ret_dict = -> dict(x=2)

    assert (ret_dict ..**> ret_args_kwargs$(1))() == ((1,), dict(x=2)) == ((..**>)(ret_dict, ret_args_kwargs$(1)))()  # type: ignore
    x = ret_dict
    x ..**>= ret_args_kwargs$(1)
    assert x() == ((1,), dict(x=2))

    assert (ret_args_kwargs$(1) <**.. ret_dict)() == ((1,), dict(x=2)) == ((<**..)(ret_args_kwargs$(1), ret_dict))()  # type: ignore
    f = ret_args_kwargs$(1)
    f <**..= ret_dict
    assert f() == ((1,), dict(x=2))

    assert data1(1) |> fmap$(-> _ + 1) == data1(2)  # type: ignore
    assert data1(1).x == 1
    assert data2(1) |> fmap$(-> _ + 1) == data2(2)  # type: ignore
    try:
        data2("a")
    except MatchError as err:
        assert err
    else:
        assert False
    assert data3(1, 2, 3).xs == (1, 2, 3)
    assert data4(x=1, y=2).kws == dict(x=1, y=2)
    assert data5(1, 2, "3").__doc__ == "docstring"
    assert data5(1, 2, "3").attr == 1
    try:
        data5(1, 2, 3)
    except MatchError as err:
        assert err
    else:
        assert False
    assert issubclass(data6, BaseClass)
    BaseClass() = data6(1)
    assert namedpt("a", 3, 4).mag() == 5
    dt = descriptor_test()
    assert dt.lam() == dt
    assert dt.comp() == (dt,)
    assert dt.N()$[:2] |> list == [(dt, 0), (dt, 1)] == dt.N_()$[:2] |> list
    assert map(Ad().ef, range(5)) |> list == range(1, 6) |> list
    assert Ad().ef 1 == 2
    assert store.plus1 store.one == store.two
    assert ret_locals()["abc"] == 1
    assert ret_globals()["abc"] == 1
    assert pos_only(1, 2) == (1, 2)
    try:
        pos_only(a=1, b=2)
    except MatchError as err:
        assert err
    else:
        assert False
    assert kwd_only(a=10) == 10
    try:
        kwd_only(10)
    except MatchError as err:
        assert err
    else:
        assert False
    try:
        kwd_only()
    except MatchError as err:
        assert err
    else:
        assert False
    assert [un_treable_func1(x) for x in range(4)] == [0, 1, 3, 6] == [un_treable_func2(x) for x in range(4)]
    assert loop_then_tre(1e4) == 0
    assert (None |?> (+)$(1)) is None
    assert (2 |?> (**)$(3)) == 9
    assert (|?>)(None, (+)$(1)) is None
    assert (|?>)(2, (**)$(3)) == 9
    x = None
    x |?>= (+)$(1)
    assert x is None
    x = 2
    x |?>= (**)$(3)
    assert x == 9
    v = vector(x=1, y=2)
    vector(x=newx, y=newy) = v
    assert (newx, newy) == (1, 2)
    data vector(x=1, y=2) = v
    data vector(1, y=2) = v
    match data vector(1, 2) in v:
        pass
    else:
        assert False
    assert vector.__match_args__ == ("x", "y") == typed_vector.__match_args__  # type: ignore
    assert Pred.__match_args__ == ("name", "args") == Pred_.__match_args__  # type: ignore
    m = Matchable(1, 2, 3)
    class Matchable(newx, newy, newz) = m
    assert (newx, newy, newz) == (1, 2, 3)
    Matchable(newx, newy, newz) = m  # type: ignore
    assert (newx, newy, newz) == (1, 2, 3)
    class Matchable(x=1, y=2, z=3) = m
    Matchable(x=1, y=2, z=3) = m
    class Matchable(1, 2, 3) = m
    Matchable(1, 2, 3) = m  # type: ignore
    match class Matchable(1, y=2, z=3) in m:
        pass
    else:
        assert False
    match Matchable(1, y=2, z=3) in m:  # type: ignore
        pass
    else:
        assert False
    try:
        Matchable(1,2,3,4) = m  # type: ignore
    except TypeError:
        pass
    else:
        assert False
    it = (|1, (|2, 3|), 4, (|5, 6|)|)
    assert eval_iters(it) == [1, [2, 3], 4, [5, 6]] == eval_iters_(it)
    assert inf_rec(5) == 10 == inf_rec_(5)
    m = methtest2()
    assert m.inf_rec(5) == 10 == m.inf_rec_(5)
    assert reqs(lazy_client)$[:10] |> list == range(10) |> list == reqs(lazy_client_)$[:10] |> list
    class T(A, B, *(C, D), metaclass=Meta, e=5)  # type: ignore
    assert T.a == 1
    assert T.b == 2
    assert T.c == 3
    assert T.d == 4
    assert T.e == 5
    d1 = {"a": 1}
    assert ret_args_kwargs(*[1], *[2], **d1, **{"b": 2}) == ((1, 2), {"a": 1, "b": 2})
    assert d1 == {"a": 1}
    try:
        ret_args_kwargs(**d1, **d1)
    except TypeError:
        pass
    else:
        assert False
    plus1 -> 4 = 3
    plus1 -> x = 5
    assert x == 6
    (plus1..plus1) -> 5 = 3
    plus1 -> plus1 -> 3 = 1
    match plus1 -> 6 in 3:
        assert False
    only_match_if(1) -> _ = 1
    match only_match_if(1) -> _ in 2:
        assert False
    only_match_int -> _ = 1
    match only_match_int -> _ in "abc":
        assert False
    only_match_abc -> _ = "abc"
    match only_match_abc -> _ in "def":
        assert False
    (-> 3) -> _ `isinstance` int = "a"  # type: ignore
    assert empty_it() |> list == [] == empty_it_of_int(1) |> list
    assert just_it(1) |> list == [1]
    assert just_it_of_int(1) |> list == [1] == just_it_of_int_(1) |> list
    assert must_be_int(4) == 4 == must_be_int_(4)
    assert typed_plus(1, 2) == 3
    (class inh_A() `isinstance` A) `isinstance` object = inh_A()
    class inh_A() `isinstance` A `isinstance` object = inh_A()
    for maxdiff in (maxdiff1, maxdiff2, maxdiff3, maxdiff_):
        assert maxdiff([7,1,4,5]) == 4, "failed for " + repr(maxdiff)
    assert all(r == 4 for r in parallel_map(of$(?, [7,1,4,5]), [maxdiff1, maxdiff2, maxdiff3]))
    assert ret_ret_func(1) == ((), {"func": 1}) == ret_args_kwargs$(func=1)()  # type: ignore
    assert ret_args_kwargs$(?, func=2)(1) == ((1,), {"func": 2})
    assert lift(ret_args_kwargs)(ident, plus1, times2, sq=square)(3) == ((3, 4, 6), {"sq": 9})
    assert plus1 `of` 2 == 3
    assert of(ret_args_kwargs, 1, 2, a=1, b=3) == ((1, 2), {"a": 1, "b": 3})
    x = y = 2
    starsum$ x y .. starproduct$ 2 2 <| 2 == 12
    assert x_and_y(x=1) == (1, 1) == x_and_y(y=1)
    ac = AccessCounter()
    ac.x = 1  # type: ignore
    assert not ac.counts
    AccessCounter(x=1) = ac
    assert ac.counts["x"] == 1
    AccessCounter(x=1) or AccessCounter(x=1) = ac
    assert ac.counts["x"] == 2
    AccessCounter(x=2) or AccessCounter(x=1) = ac
    assert ac.counts["x"] == 4
    tree() = empty()
    class tree() = leaf(1)
    match data tree() in leaf(1):
        assert False
    match tree() in leaf(1):
        assert False
    x = y = -1
    x `flip(of)` is_even or y = 2
    assert x == 2
    assert y == -1
    x `(x, f) -> f(x)` is_even or y = 3
    assert x == 2
    assert y == 3
    ((def (x if is_even(x)) -> x) -> x) or y = 4
    assert x == 4
    assert y == 3
    ((def (x if is_even(x)) -> x) -> x) or y = 5
    assert x == 4
    assert y == 5
    x `match_if` is_even or y = 6
    assert x == 6
    assert y == 5
    for mp in (matching_parens_1, matching_parens_2, matching_parens_3, matching_parens_4):
        assert mp(""), mp
        assert mp("()"), mp
        assert not mp(")("), mp
        assert not mp("("), mp
        assert not mp(")"), mp
        assert mp("()()"), mp
        assert mp("(())"), mp
        assert mp("(a(b)c(d)e)f(g)"), mp
        assert not mp("((())))()"), mp
    assert min_and_max(range(10)) == (0, 9)
    assert odd_digits_to_chars("a1c1e1") == "abcdef"
    assert odd_digits_to_chars("a1b2c3d4e") == "abbdcfdhe"
    assert truncate_sentence(2)("hello how are you") == "hello how"
    assert maxcolsum([range(3), range(1,4)]) == 6 == range(1, 4) |> sum
    (assert)(unrepresentable(), unrepresentable())  # type: ignore
    l = [199, 200, 208, 210, 200, 207, 240, 269, 260, 263]
    assert l |> binary_reduce$(<) |> sum == 7 == l |> binary_reduce_$(<) |> sum
    assert range(10)$[:last()] == range(10) == range(10)[:last()]
    assert range(10)$[:last(0)] == range(10) == range(10)[:last(0)]
    assert range(10)$[:last(1)] == range(10)[:-1] == range(10)[:last(1)]
    assert range(10)$[:`end`] == range(10) == range(10)[:`end`]
    assert range(10)$[:`end-0`] == range(10) == range(10)[:`end-0`]
    assert range(10)$[:`end-1`] == range(10)[:-1] == range(10)[:`end-1`]
    assert final_pos("""
forward 5
down 5
forward 8
up 3
down 8
forward 2""") == 150
    assert final_aim("""
forward 5
down 5
forward 8
up 3
down 8
forward 2""") == 900
    s = """
00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010
    """.strip().split("\n")
    assert gam_eps_rate(s) == 198 == gam_eps_rate_(s)
    assert vector(1, 2)._replace(x=3)._asdict() == {"x": 3, "y": 2} == typed_vector(1, 2)._replace(x=3)._asdict()
    assert lenient_2vec("1", "2")._asdict() == {"x": 1, "y": 2} == Point(1, 2)._asdict()
    assert lenient_2vec("1", 2.5)._asdict() == {"x": 1, "y": 2} == lenient_2vec(1.5, "2")._asdict()
    assert manyvec(1, 2, 3)._asdict() == {"xs": (1, 2, 3)} == manyvec(4, 5)._replace(xs=(1, 2, 3))._asdict()
    def tup3(a: int, b: int, c: int?=None) = a, b, c
    assert flip(tup3)(2, 1, 3) == (3, 1, 2)
    assert flip(tup3, 2)(2, 1, 3) == (1, 2, 3)
    assert flip2(tup3)(2, 1, 3) == (1, 2, 3) == flip2_(tup3)(2, 1, 3)  # type: ignore
    assert flip(tup3)(2, 1, c=3) == (1, 2, 3) == flip(tup3, 2)(2, 1, c=3)
    assert ", 2" in repr(flip2(tup3))
    assert tup3 `of_data` (a=1, b=2, c=3) == (1, 2, 3)  # type: ignore
    assert get_frame().f_locals["secret"] == "hidden"
    assert first_twin((2, 3, 5, 7, 11)) == (3, 5) == first_twin_((2, 3, 5, 7, 11))
    assert has_abc("abc")
    assert has_abc("abcdef")
    assert has_abc("xyzabcdef")
    assert not has_abc("aabbcc")
    assert split1_comma("1,2,3") == ("1", "2,3")
    assert split1_comma("ab,cd,ef") == ("ab", "cd,ef")
    assert split1_comma("1,") == ("1", "")
    assert split1_comma(",2") == ("", "2")
    assert split1_comma(",") == ("", "")
    assert split1_comma("abcd") == ("abcd", "")
    assert primes()$[:5] |> tuple == (2, 3, 5, 7, 11)
    assert twin_primes()$[:5] |> list == [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)]
    assert stored_default(2) == [2, 1] == stored_default_cls()(2)
    assert stored_default(2) == [2, 1, 2, 1] == stored_default_cls()(2)
    if sys.version_info >= (3,):  # naive namespace classes don't work on py2
        assert stored_default_cls.stored_default(3) == [2, 1, 2, 1, 3, 2, 1]  # type: ignore
    bad = assert_raises$(exc=TypeError)
    tr = triangle(1, 2, 3)
    tv = typed_vector(1, 2)

    bad(-> tr + (4,))
    bad(-> tv + (3,))

    bad(-> tv + tr)
    bad(-> tr + tv)

    bad(def -> tr_ = tr; tr_ += (4,))
    bad(def -> tv_ = tv; tv_ += (3,))

    bad(-> tr * 2)
    bad(-> tv * 2)

    bad(-> 2 * tr)
    bad(-> 2 * tv)

    bad(def -> tr_ = tr; tr_ *= 2)
    bad(def -> tv_ = tv; tv_ *= 2)

    assert (x=1, y=2) + (3,) == (1, 2, 3)  # type: ignore
    assert tricky_tco(-> True) is True
    assert is_complex_tree(HasElems(
        1,
        2,
        3,
        HasVal(
            HasThreeVals(
                val1=[HasTwoVals("a", "b")],
                val2=[],
                val3=[],
            )
        ),
    ))
    assert not is_complex_tree(HasElems(
        1,
        2,
        3,
        HasVal(
            HasThreeVals(
                val1=[HasTwoVals("a", "c")],
                val2=[],
                val3=[],
            )
        ),
    ))
    A(.a=1) = A()
    match A(.a=2) in A():
        assert False
    assert_raises((def -> A(.b=1) = A()), AttributeError)
    assert MySubExc("derp") `isinstance` Exception
    assert A().not_super() is True
    match class store.A(1) = store.A(1)
    match data store.A(1) = store.A(1)
    match store.A(1) = store.A(1)
    match store.A(1) in store.A(1):
        pass
    else:
        assert False
    assert ret_args_kwargs$(?, x=1)(1, x=2) == ((1,), {"x": 2})
    assert ret_args_kwargs$(?, x=?, y=?)(1, 2, 3) == ((1,), {"x": 2, "y": 3})
    assert ret_args_kwargs$(x=?)(1, y=2) == ((), {"x": 1, "y": 2})
    assert ret_args_kwargs$(1, x=?)(2) == ((1,), {"x": 2})
    assert {1:"2", 2:"3"} |> old_fmap$((k, v) -> (k+1, v+"!")) == {2:"2!", 3:"3!"}
    assert {1:"2", 2:"3"} |> fmap$(def ((k, v)) -> (k+1, v+"!")) == {2:"2!", 3:"3!"}
    assert 2 |> (.`plus`3) == 5
    X = Arr((2,2), [1,2;;3,4])
    assert [X;X] == Arr((2,4), [1,2,1,2;;3,4,3,4]) == Arr((2,4), [X.arr; X.arr])
    assert [X;;X] == Arr((4,2), [1,2;;3,4;;1,2;;3,4]) == Arr((4,2), [X.arr;;X.arr])
    assert [X;;;X] == Arr((2,2,2), [1,2;;3,4;;;1,2;;3,4]) == Arr((2,2,2), [X.arr;;;X.arr])
    assert 10 <$ [1, 2, 3] == [10, 10, 10] == (<$)(10, [1, 2, 3])
    assert [1, 2, 3] |> (10 <$ .) == [10, 10, 10]
    ten = 10
    one_two_three = Arr((3,), [1, 2, 3])
    assert ten<$one_two_three == Arr((3,), [10, 10, 10])
    assert ten*2 <$ -one_two_three == Arr((3,), [20, 20, 20])
    assert 10 <$ one_two_three |> fmap$(.+1) == Arr((3,), [11, 11, 11])
    assert !!ten
    assert ten!!
    assert not !!0
    assert not 0!!
    assert range(3) |> map$(!!) |> list == [False, True, True]
    assert lol lol lol == "lololol"
    lol lol
    assert 1++ == 2 == ++1
    assert ( * ) is operator.mul
    assert 2***3 == 16
    assert ( *** ) is (***)
    match x ?int in 5:
        assert x == 5
    else:
        assert False
    match x ?int in 5.0:
        assert False
    assert CONST |> (.+1) == 11
    assert "abc1020" == “"abc"” “10” “20”
    assert !0 == 1
    assert ![] is True
    assert (<$).__name__ == '_coconut_op_U3c_U24' == f"{(<$).__name__}"
    a_list: list_or_tuple = [1, 2, 3]
    a_list = (1, 2, 3)
    a_func: func_to_int = (.+1)
    a_tuple: TupleOf[int] = a_list
    a_seq: Seq[int] = a_tuple
    a_dict: TextMap[str, int] = {"a": 1}
    assert HasT().T == 1
    assert dict_zip({"a": 1, "b": 2}, {"a": 3, "b": 4}) == {"a": [1, 3], "b": [2, 4]}
    assert intdata(x=2).x == 2 == intdata_(x=2).x
    assert weird_recursor()
    summer.acc = 0
    summer.args = list(range(100_000))
    assert summer() == sum(range(100_000))
    assert util_doc == "docstring"

    # must come at end
    assert fibs_calls[0] == 1
    assert lols[0] == 5
    return True

def tco_test() -> bool:
    """Executes suite tests that rely on TCO."""
    assert is_even(5000) and is_odd(5001)
    assert is_even_(5000) and is_odd_(5001)
    assert hasattr(ret_none, "_coconut_tco_func")
    assert hasattr(tricky_tco, "_coconut_tco_func")
    assert methtest().recurse_n_times(100_000) == "done!"
    return True
