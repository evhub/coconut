# Imports:
import sys
import random
import operator  # NOQA
from contextlib import contextmanager
from functools import wraps
from collections import defaultdict

__doc__ = "docstring"

# Helpers:
def rand_list(n):
    '''Generate a random list of length n.'''
    return [random.randrange(10) for x in range(0, n)]

class AccessCounter():
    '''A class that counts the number of times it is accessed.'''
    def __init__(self):
        self.counts = defaultdict(int)
    def __getattribute__(self, attr):
        if attr != "counts":
            self.counts[attr] += 1
        return super(AccessCounter, self).__getattribute__(attr)

def assert_raises(c, exc=Exception):
    """Test whether callable c raises an exception of type exc."""
    try:
        c()
    except exc:
        pass
    except BaseException as err:
        raise AssertionError(f"got wrong exception {err} (expected {exc})")
    else:
        raise AssertionError(f"{c} failed to raise exception {exc}")

try:
    prepattern()  # type: ignore
except NameError, TypeError:
    def prepattern(base_func, **kwargs):  # type: ignore
        """Decorator to add a new case to a pattern-matching function,
        where the new case is checked first."""
        def pattern_prepender(func):
            return addpattern(func, base_func, **kwargs)
        return pattern_prepender

# Old functions:
old_fmap = fmap$(starmap_over_mappings=True)

# Infix Functions:
plus = (+)
mod: (int, int) -> int = (%)
def (a: int) `mod_` (b: int) -> int = a % b
base = int
def a `join_with` (b=""):
    return b.join(a)
def obj `match_if` (predicate: -> bool) -> bool =
    """Meant to be used in infix pattern-matching expressions to match the left-hand side only if the predicate on the right-hand side holds.

    For example:
        a `match_if` predicate or b = obj

    The actual definition of match_if is extremely simple:
        def match_if(obj, predicate) = predicate(obj)
    """
    predicate(obj)

# Composable Functions:
plus1 = (1+.)
square = (.**2)
times2 = (2*.)

# Function Compositions:
plus1sq_1 = square..plus1  # type: ignore
sqplus1_1 = plus1
sqplus1_1 ..= square  # type: ignore

plus1sq_2 = (x) -> x |> plus1 |> square  # type: ignore
sqplus1_2 = (x) -> x |> square |> plus1

plus1sq_3 = square <.. plus1
sqplus1_3 = plus1
sqplus1_3 <..= square  # type: ignore

plus1sq_4 = plus1 ..> square
sqplus1_4 = square
sqplus1_4 ..>= plus1  # type: ignore

def plus1sq_5(x) = z where:
    y = x+1
    z = y**2
def sqplus1_5(x) = z where:
    y = x**2
    z = y+1

square_times2_plus1 = square ..> times2 ..> plus1
square_times2_plus1_ = plus1 <.. times2 <.. square
plus1_cube = plus1 ..> x -> x**3

def plus1_all(*args) = map(plus1, args)
def square_all(*args) = map(square, args)
def times2_all(*args) = map(times2, args)

plus1sq_all = square_all <*.. plus1_all
sqplus1_all = plus1_all
sqplus1_all <*..= square_all

plus1sq_all_ = plus1_all ..*> square_all
sqplus1_all_ = square_all
sqplus1_all_ ..*>= plus1_all

square_times2_plus1_all = square_all ..*> times2_all ..*> plus1_all
square_times2_plus1_all_ = plus1_all <*.. times2_all <*.. square_all

plus1_square_times2_all = (..*>)(plus1_all, square_all, times2_all)
plus1_square_times2_all_ = (<*..)(times2_all, square_all, plus1_all)

plus1sqsum_all = plus1_all ..*> square_all ..> sum
plus1sqsum_all_ = sum <.. square_all <*.. plus1_all

min_and_max = min `lift(,)` max

# Basic Functions:
product = reduce$((*), ?, 1)
product_ = reduce$(*)
def zipwith(f, *args) = map((items) -> f(*items), zip(*args))
def zipwith_(f, *args) = starmap$(f)..zip <*| args
zipsum = zip ..> map$(sum)
ident_ = (x) -> x
@ ident .. ident  # type: ignore
def plus1_(x: int) -> int = x + 1
def sqrt(x: int) -> float = x**0.5
def sqrt_(x) = x**0.5
clean = (s) -> s.strip()
add2 = (x) -> (y) -> x + y
def swap2(f) = (x, y) -> f(y, x)
swap2_ = (f) -> (x, y) -> f(y, x)
def same(iter1, iter2) = map((==), iter1, iter2)
def chain2(a, b):
    yield from a
    yield from b
def threeple(a, b, c) = (a, b, c)
def toprint(*args) = " ".join(str(a) for a in args)
def starsum(*args) = sum(args)
def starproduct(*args) = product(args)
flip2 = flip$(nargs=2)
flip2_ = flip$(?, 2)
def of_data(f, d) = f(**d._asdict())

# Partial Applications:
sum_ = reduce$((+))
add = zipwith$((+))
add_ = zipwith_$(+)

# Operators:
operator <$  # fmapConst
def x <$ xs = fmap(-> x, xs)

operator !!  # bool
(!!) = bool

operator lol
lols = [-1]
match def lol = "lol" where:
    lols[0] += 1
addpattern def (s) lol = s + "ol" where:  # type: ignore
    lols[0] += 1
lol

operator ***
match def x***(1) = x
addpattern def x***y = (x *** (y-1)) ** x  # type: ignore

:operator ?int
def x ?int = x `isinstance` int

operator CONST
def CONST = 10

operator “
operator ”
(“) = (”) = (,) ..> map$(str) ..> "".join

operator !
match def (int(x))! = 0 if x else 1
addpattern def (float(x))! = 0.0 if x else 1.0  # type: ignore
addpattern def x! if x = False  # type: ignore
addpattern def x! = True  # type: ignore

# Type aliases:
if sys.version_info >= (3, 5) or TYPE_CHECKING:
    import typing

    type list_or_tuple = list | tuple

    type func_to_int = -> int

    type Seq[T] = T[]

    type TupleOf[T] = typing.Tuple[T, ...]

    type TextMap[T <: typing.Text, U] = typing.Mapping[T, U]

class HasT:
    T = 1

# Quick-Sorts:
def qsort1(l: int[]) -> int[]:
    '''Non-Functional Quick Sort.'''
    if len(l) == 0:
        return []
    else:
        l = list(l)
        split = l.pop()
        smalls = []
        larges = []
        for x in l:
            if x <= split:
                smalls.append(x)
            else:
                larges.append(x)
        return list(qsort1(smalls)) + [split] + list(qsort1(larges))
def qsort2(l: int[]) -> int[]:
    """Functional Quick Sort."""
    if not l:
        return []
    else:
        head, tail = l[0], l[1:]# Python Pattern-Matching
        return (list(qsort2([x for x in tail if x <= head]))
                + [head] # The pivot is a list
                + list(qsort2([x for x in tail if x > head]))
                )
def qsort3(l: int$[]) -> int$[]:
    """Iterator Quick Sort."""
    try:
        tail, tail_ = l |> iter |> tee
        # Since only iter is ever called on l, and next on tail, l only has to be an iterator
        head = next(tail)
        return (qsort3((x for x in tail if x <= head))  # an extra comment
                :: (head,) # The pivot is a tuple
                :: qsort3((x for x in tail_ if x > head))
                )
    except StopIteration:
        return iter(())
def qsort4(l: int[]) -> int[]:
    """Match Quick Sort."""
    cases l:
        match []:
            return l
        match [head] + tail:
            return (list(qsort4([x for x in tail if x <= head])) # an extra comment
                    + [head] # The pivot is a list
                    + list(qsort4([x for x in tail if x > head])) # another extra comment
                    )
    return None  # type: ignore
def qsort5(l: int$[]) -> int$[]:
    """Iterator Match Quick Sort."""
    match (head,) :: tail in l:  # type: ignore
        tail, tail_ = tee(tail)
        return (qsort5((x for x in tail if x <= head))
            :: (head,) # The pivot is a tuple
            :: qsort5((x for x in tail_ if x > head))  # an extra comment
            )
    else:
        return iter(())
def qsort6(l: int$[]) -> int$[]:
    match [head] :: tail in l:  # type: ignore
        tail = reiterable(tail)  # type: ignore
        yield from (
            qsort6(x for x in tail if x <= head)
            :: (head,)
            :: qsort6(x for x in tail if x > head)
        )

def empty_list_base_case([]) = []

# use separate name for base func for pickle
def _qsort7([head] + tail) =
    qsort7(left) + [head] + qsort7(right) where:
        left = [x for x in tail if x <= head]
        right = [x for x in tail if x > head]
qsort7 = addpattern(empty_list_base_case)(_qsort7)

# use separate name for base func for pickle
def _qsort8(l) =
    qsort8(left) + [mid] + qsort8(right) where:
        midpt = len(l)//2
        mid, rest = l[midpt], l[:midpt] + l[midpt+1:]
        left = [x for x in rest if x < mid]
        right = [x for x in rest if x >= mid]
qsort8 = addpattern(empty_list_base_case)(_qsort8)


# Infinite Iterators:
def repeat(elem):
    """Repeat Iterator."""
    while True:
        yield elem
def repeat_(elem):
    return (elem,) :: repeat_(elem)
def N(n=0) -> typing.Iterator[int]:
    """Natural Numbers."""
    while True:
        yield n
        n += 1
def N_(n=0):
    return (n,) :: N_(n+1)
def N__(n=0):
    it = n,
    it ::= N__(n+1)
    return it
def preN(it):
    it ::= N()
    return it
def map_iter(func, args):
    match (| x |) :: xs in args:
        yield from (| func(x) |) :: map_iter(func, xs)

# Recursive Functions:

def next_mul_of(n, x):
    if x % n == 0:
        return x
    else:
        return next_mul_of(n, x+1)

def collatz(n):
    """this is a docstring"""
    if n == 1:
        return True
    elif n%2 == 0:
        return collatz(n/2)
    else:
        return collatz(3*n+1)

def recurse_n_times(n) =
    """this is a docstring"""
    if not n:
        return True
    recurse_n_times(n-1)

def is_even(n) =
    if not n:
        return True
    is_odd(n-1)
def is_odd(n) =
    if not n:
        return False
    is_even(n-1)

def is_even_(0) = True
addpattern def is_even_(n) = is_odd_(n-1)  # type: ignore

def is_odd_(0) = False
addpattern def is_odd_(n) = is_even_(n-1)  # type: ignore

# TCO/TRE tests:

def tco_chain(it) =
    consume(it :: ["last"], keep_last=1)

def partition(items, pivot, lprefix=[], rprefix=[]):
    cases items:
        match [head]::tail:
            if head < pivot:
                return partition(tail, pivot, [head]::lprefix, rprefix)
            else:
                return partition(tail, pivot, lprefix, [head]::rprefix)
        match []::_:
            return lprefix, rprefix
partition_ = recursive_iterator(partition)

def myreduce(func, items):
    match [first]::tail1 in items:
        match [second]::tail2 in tail1:
            return myreduce(func, [func(first, second)]::tail2)
        else:
            return first

def fake_recurse_n_times(n) =
    fake_recurse_n_times = recurse_n_times
    fake_recurse_n_times(n)

def return_in_loop(x):
    if x == 0:
        return True
    while True:
        return return_in_loop(x - 1)

class methtest:
    def meth(self, arg) = meth(self, arg)
    def tail_call_meth(self, arg) = self.meth(arg)
    @staticmethod
    def recurse_n_times(n):
        if n == 0: return "done!"
        return methtest.recurse_n_times(n-1)

def meth(self, arg) = arg

def un_treable_func1(x, g=-> _):
    if x == 0:
        return g(x)
    px = y -> y + x
    gp = y -> px(g(y))
    return un_treable_func1(x-1, gp)

def un_treable_func2(x, g=-> _):
    if x == 0:
        return g(x)
    def px(y): return y + x
    def gp(y): return px(g(y))
    return un_treable_func2(x-1, gp)

def loop_then_tre(n):
    if n == 0:
        return 0
    for i in range(1):
        pass
    return loop_then_tre(n-1)

def returns_ten(func):
    @wraps(func)
    def returns_ten_func(*args, **kwargs) = 10
    return returns_ten_func

@returns_ten
def inf_rec(x) = inf_rec(x)

def inf_rec_(x) = inf_rec_(x)
inf_rec_ = returns_ten(inf_rec_)

class methtest2:
    @returns_ten
    def inf_rec(self, x) = self.inf_rec(x)
    def inf_rec_(self, x) = self.inf_rec_(x)
methtest2.inf_rec_ = returns_ten(methtest2.inf_rec_)  # type: ignore

def ret_ret_func(func) = ret_args_kwargs(func=func)

def get_frame() =
    secret = "hidden"
    sys._getframe()

def stored_default(x, l=[]):
    if not x:
        return l
    l.append(x)
    return stored_default(x-1)

class stored_default_cls:

    def stored_default(x, l=stored_default(0)):
        if not x:
            return l
        l.append(x)
        return stored_default(x-1)

    def __call__(self, x, l=[]):
        if not x:
            return l
        l.append(x)
        return self.__call__(x-1)

def tricky_tco(func):
    try:
        # a comment
        return (raise)(TypeError())

    except TypeError:
        return func()

weird_recursor_ns = [50]

def weird_recursor(n):
    if n == 0:
        weird_recursor_ns.pop()
        return True
    weird_recursor_ns[-1] -= 1
    return weird_recursor()  # type: ignore

@prepattern(weird_recursor)  # type: ignore
match def weird_recursor() = weird_recursor(weird_recursor_ns[-1])

def summer():
    if not summer.args:
        return summer.acc
    summer.acc += summer.args.pop()
    return summer()


# Data Blocks:
try:
    datamaker()  # type: ignore
except NameError, TypeError:
    def datamaker(data_type):  # type: ignore
        """Get the original constructor of the given data type or class."""
        return makedata$(data_type)

data preop(x, y):
    def add(self):
        return self.x + self.y
data vector(x, y):
    def __new__(cls, x, y: int? = None):
        match vector(x, y) in x:
            pass
        return datamaker(cls)(x, y)
    def __abs__(self):
        return (self.x**2 + self.y**2)**.5
    def transform(self, other):
        match vector(x, y) in other:
            return vector(self.x + x, self.y + y)
        else:
            raise TypeError()
    def __add__(self, vector(x_, y_)) =  # type: ignore
        vector(self.x + x_, self.y + y_)
    addpattern def __add__(self, int() as n) =  # type: ignore
        vector(self.x + n, self.y + n)
    __radd__ = __add__
data triangle(a, b, c):
    def is_right(self):
        return self.a**2 + self.b**2 == self.c**2
data null1: pass
data null2(): pass
null = (null1, null2)
def is_null(item):
    match null() in item:
        return True
    else:
        return False
data Elems(elems):
    def __new__(cls, *elems) =
        elems |> datamaker(cls)
data vector_with_id(x, y, i) from vector  # type: ignore
data typed_vector(x:int=0, y:int=0):
    def __abs__(self):
        return (self.x**2 + self.y**2)**.5

# Factorial:
def factorial1(value):
    match 0 in value: return 1
    match int() as n in value if n > 0: return n * factorial1(n-1)
def factorial2(value):
    match (0) in value:
        return 1
    else: match (int() as n) in value if n > 0:
        return n * factorial2(n-1)
    else:
        return None
    raise TypeError()
def factorial3(value):
    match 0 in value:
        return 1
    match int() as n in value if n > 0:
        return n * factorial3(n-1)
    match [] in value:
        return []
    match [head] + tail in value:
        return [factorial3(head)] + factorial3(tail)
def factorial4(value):
    cases value:
        match 0: return 1
        match int() as n if n > 0: return n * factorial4(n-1)
def factorial5(value):
    cases value:
        match 0:
            return 1
        match int() as n if n > 0:
            return n * factorial5(n-1)
    else:
        return None
    raise TypeError()

match def fact(n) = fact(n, 1)  # type: ignore
match addpattern def fact(0, acc) = acc  # type: ignore
addpattern match def fact(n, acc) = fact(n-1, acc*n)  # type: ignore

def factorial(0, acc=1) = acc
addpattern def factorial(int() as n, acc=1 if n > 0) =  # type: ignore
    """this is a docstring"""
    factorial(n-1, acc*n)

# Match Functions:
def classify(value):
    match tuple() in value:
        match () in value:
            return "empty tuple"
        match (_,) in value:
            return "singleton tuple"
        match (x,x) in value:
            return "duplicate pair tuple of "+str(x)
        match (_,_) in value:
            return "pair tuple"
        return "tuple"
    match list() in value:
        match [] in value:
            return "empty list"
        match [_] in value:
            return "singleton list"
        match [x,x] in value:
            return "duplicate pair list of "+str(x)
        match [_,_] in value:
            return "pair list"
        return "list"
    match {} in value:
        match {**{}} in value:
            return "empty dict"
        else:
            return "dict"
    match _ `isinstance` (set, frozenset) in value:
        match s{} in value:
            return "empty set"
        match {0} in value:
            return "set of 0"
        return "set"
    raise TypeError()
def classify_sequence(value):
    out = ""
    cases value:
        match ():
            out += "empty"
        match (_,):
            out += "singleton"
        match (x,x):
            out += "duplicate pair of "+str(x)
        match (_,_):
            out += "pair"
        match (_,_,_) or (_,_,_,_):
            out += "few"
    else:
        raise TypeError()
    return out
def dictpoint(value):
    match {"x":int() as x, "y":int() as y} in value:
        return (x, y)
    else:
        raise TypeError()
def map_(func, args):
    match l and (() or []) in args:
        return l
    match (x,) + xs in args if args `isinstance` tuple:
        return (func(x),) + map_(func, xs)
    match [x] + xs in args if args `isinstance` list:
        return [func(x)] + map_(func, xs)
def duplicate_first1(value):
    match [x] + xs as l in value:
        return [x] + l
    else:
        raise TypeError()
def duplicate_first2(value):
    match [x] :: xs `isinstance` list as l in value:
        return [x] :: l
    else:
        raise TypeError()
def one_to_five(l):
    match [1] + m + [5] in l:
        return m
    else:
        return False
def list_type(xs):
    cases reiterable(xs):
        match [fst, snd] :: tail:
            return "at least 2"
        match [fst] :: tail:
            return "at least 1"
        match (| |):
            return "empty"

# Unicode Functions:
square_u = (x) → x ↑ 2
def neg_u(x) = ⁻x
neg_square_u = (x) → x ↦ square_u ↦ neg_u

# In-Place Functions:
def pipe(a, b):
    a |>= b
    return a
def compose(a, b):
    a ..= b
    return a
def chain(a, b):
    a ::= b
    return a

# Algebraic Data Types:
data empty(): pass
data leaf(n): pass
data node(l, r): pass
tree = (empty, leaf, node)

def depth_1(t):
    match tree() in t:
        return 0
    match tree(n) in t:
        return 1
    match tree(l, r) in t:
        return 1 + max([depth_1(l), depth_1(r)])

def depth_2(t):
    match tree() in t:
        return 0
    match tree(n=n) in t:
        return 1
    match tree(l=l, r=r) in t:
        return 1 + max([depth_2(l), depth_2(r)])

# Monads:
def base_maybe(x, f) = f(x) if x is not None else None
def maybes(*fs) = reduce(base_maybe, fs)

data Nothing():
    def __call__(self, *args):
        return Nothing()
data Just(item):
    def __call__(self, *args):
        return Just <| reduce((|>), args, self.item)
Maybe = (Nothing, Just)

# Destructuring Assignment:
def head_tail(l):
    match [head] + tail = l
    return head, tail
def init_last(l):
    init + [last] = l
    return init, last
def last_two(l):
    _ + [a, b] = l
    return a, b
def delist2(l):
    match data list(a, b) = l
    return a, b
def delist2_(l):
    data list(a, b)  = l
    return a, b

# Optional Explicit Assignment:
def expl_ident(x) = x
def dictpoint_(value):
    {"x":int() as x, "y":int() as y} = value
    return x, y
def dictpoint__({"x":int() as x, "y":int() as y}):
    return x, y
def `tuple1` a = a,
def a `tuple1_` = a,
def a `tuple2` b = a, b
def tuple2_(a, b) = a, b

# Enhanced Decorators:
@ (f) -> f
def dectest(x) = x

# Match Function Definition:
def last_two_(_ + [a, b]):
    return a, b
match def htsplit([head] + tail) = [head, tail]
def htsplit_([head] + tail) = [head, tail]
match def (int() as x) `iadd` (int() as y) =
    """this is a docstring"""
    x + y
def (int() as x) `iadd_` (int() as y) = x + y
match def strmul(str() as a, int() as x):
    return a * x
def strmul_(str() as a, int() as x):
    return a * x

# Lazy Lists:
class lazy:
    done = False
    def finish(self):
        self.done = True
    def \list(self):
        return (| 1, 2, 3, self.finish() |)
def is_empty(i):
    match (||) in i:
        return True
    else:
        return False
def is_one(i):
    match (| 1 |) in i:
        return True
    else:
        return False

# Constructed Data Types:
data trilen(h):
    def __new__(cls, a, b):
        return (a**2 + b**2)**0.5 |> datamaker(cls)

# Inheritance:
class A:
    a = 1
    def true(self):
        return True
    def not_super(self):
        def \super() = self
        return super().true()
    @classmethod
    def cls_true(cls) = True
class inh_A(A):
    def inh_true1(self) =
        super().true()
    def inh_true2(self) =
        super(inh_A, self).true()
    def inh_true3(nonstandard_self) =
        super().true()
    def inh_true4(self) =
        py_super(inh_A, self).true()
    inh_true5 = def (self) -> super().true()
    @classmethod
    def inh_cls_true(cls) = super().cls_true()
class B:
    b = 2
class C:
    c = 3
class D:
    d = 4

class MyExc(Exception):
    def __init__(self, m):
        super().__init__(m)

class MySubExc(MyExc):
    def __init__(self, m):
        super().__init__(m)

# Nesting:
class Nest:
    class B:
        class C:
            d = "data"
            def m(self) = "method"
            none = None
        c = C()
    b = B()

# Infinite Grid:

data pt(x, y):
    """Cartesian point in the x-y plane. Immutable."""
    def __abs__(self):
        return (self.x**2 + self.y**2)**0.5

def vertical_line(x=0, y=0):
    """Infinite iterator of pt representing a vertical line."""
    return (pt(x, y), ) :: vertical_line(x, y+1)

def grid(x=0):
    """Infinite iterator of infinite iterators representing cartesian space."""
    return (vertical_line(x, 0), ) :: grid(x+1)

def grid_map(func, gridsample):
    """Map a function over every point in a grid."""
    return gridsample |> map$(map$(func))

def parallel_grid_map(func, gridsample):
    """Map a function over every point in a grid in parallel."""
    return gridsample |> parallel_map$(parallel_map$(func))

def grid_trim(gridsample, xmax, ymax):
    """Convert a grid to a list of lists up to xmax and ymax."""
    return gridsample$[:xmax] |> map$((l) -> l$[:ymax] |> list) |> list

# Physics function:

def SHOPeriodTerminate(X, t, params):
    if X[1] > 0:
        return -1 # passed the turning point, so go back
    epsilon = params['epsilon'] if 'epsilon' in params else 1e-8
    if abs(X[1]) < epsilon and X[0] < 0:
        return 1  # we're done
    return 0     # keep going

# Multiple dispatch:
def add_int_or_str_1(int() as x) = x + 1
addpattern def add_int_or_str_1(str() as x) = x + "1"  # type: ignore

def coercive_add(int() as a, b) = a + int(b)
addpattern def coercive_add(str() as a, b) = a + str(b)  # type: ignore

@addpattern(ident, allow_any_func=True)
def still_ident(x) =
    """docstring"""
    "foo"

@prepattern(ident, allow_any_func=True)
def not_ident(x) = "bar"

# Pattern-matching functions with guards

def pattern_abs(x if x < 0) = -x
addpattern def pattern_abs(x) = x  # type: ignore

def `pattern_abs_` (x) if x < 0 = -x
addpattern def `pattern_abs_` (x) = x  # type: ignore

# Recursive iterator

@recursive_iterator
def fibs() =
    fibs_calls[0] += 1
    (1, 1) :: map((+), fibs(), fibs()$[1:])

fibs_calls = [0]

@recursive_iterator
def fibs_() = map((+), (1, 1) :: fibs_(), (0, 0) :: fibs_()$[1:])

# use separate name for base func for pickle
def _loop(it) = it :: loop(it)
loop = recursive_iterator(_loop)

@recursive_iterator
def nest(x) = (|x, nest(x)|)

# Sieve Example

def sieve((||)) = []

@prepattern(sieve)  # type: ignore
def sieve([head] :: tail) = [head] :: sieve(n for n in tail if n % head)  # type: ignore

# "Assignment function" definitions

def double_plus_one(x: int) -> int =
    x *= 2
    x + 1

def assign_func_1(f, x, y) =
    def inner_assign_func((a, b)) = f(a, b)
    inner_assign_func((x, y))

def assign_func_2(f, x, y) =
    def inner_assign_func((a, b)) =
        f(a, b)
    inner_assign_func((x, y))

# Composable Functions

mul = (*)
def minus(a, b) = b - a

# Exception Functions

def raise_exc():
    raise Exception("raise_exc")

def does_raise_exc(func):
    try:
        return func()
    except Exception:
        return True

# Returns

def ret_none(n):
    if n != 0:
        return ret_none(n - 1)

def ret_args_kwargs(*args, **kwargs) = (args, kwargs)

def ret_args(*args) = args

# Useful Classes

class identity_operations:
    def __getitem__(self, args) = args
    def method(self, *args, **kwargs) = (args, kwargs)
identity = identity_operations()

class container:
    def __init__(self, x):
        self.x = x
    def __eq__(self, other) =
        isinstance(other, container) and self.x == other.x

class container_(\(object)):
    def __init__(self, x):
        self.x = x
    def __eq__(self, other) =
        isinstance(other, container_) and self.x == other.x

class counter:
    \count = 0
    def inc(self):
        self.count += 1

class unrepresentable:
    class Fail(Exception)
    def __repr__(self):
        raise Fail("unrepresentable")

# Typing
if TYPE_CHECKING or sys.version_info >= (3, 5):
    from typing import List, Dict, Any, cast
else:
    def cast(typ, value) = value

def args_kwargs_func(args: List[Any]=[], kwargs: Dict[Any, Any]={}) -> typing.Literal[True] =
    True

def int_func(*args: int, **kwargs: int) -> int =
    0

def one_int_or_str(x: int | str) -> int | str = x

def must_be_int(int() as x) -> int = cast(int, x)
def must_be_int_(int() as x) -> int: return cast(int, x)

def (int() as x) `typed_plus` (int() as y) -> int = x + y

# Enhanced Pattern-Matching

def fact_(0, acc=1) = acc
addpattern def fact_(int() as n, acc=1 if n > 0) = fact_(n-1, acc*n)  # type: ignore

def x_is_int(int() as x) = x

def x_as_y(x as y) = (x, y)

def (int() as x) `x_y_are_int_gt_0` (int() as y) if x > 0 and y > 0 = (x, y)

def x_is_int_def_0(int() as x = 0) = x

def head_tail_def_none([head] + tail = [None]) = (head, tail)

match def kwd_only_x_is_int_def_0(*, int() as x = 0) = x

match def must_pass_x(*xs, x) = (xs, x)

def no_args_kwargs(*(), **{**{}}) = True

def x_and_y(x and y) = (x, y)

# Alternative Class Notation

class altclass:
    func: (Any, Any) -> Any
    zero: (Any, int) -> int

def altclass.func(self, x) = x  # type: ignore

def altclass.zero(self, x: int) -> int =  # type: ignore
    if x == 0:
        return 0
    altclass.zero(self, x-1)  # tail recursive

# Logic Stuff

class Vars:
    var_one = 1

    @classmethod
    def items(cls):
        for name, var in vars(cls).items():
            if not name.startswith("_"):
                yield name, var
    @classmethod
    def use(cls, globs=None):
        """Put variables into the global namespace."""
        if globs is None:
            globs = globals()
        for name, var in cls.items():
            globs[name] = var
    @classmethod
    @contextmanager
    def using(cls, globs=None):
        """Temporarily put variables into the global namespace."""
        if globs is None:
            globs = globals()
        prevars = {}
        for name, var in cls.items():
            if name in globs:
                prevars[name] = globs[name]
            globs[name] = var
        try:
            yield
        finally:
            for name, var in cls.items():
                if name in prevars:
                    globs[name] = prevars[name]
                else:
                    del globs[name]

# Complex Data
data manyvec(*xs)

data Tuple_(*elems)

data Pred(name, *args)
data Pred_(name: str, *args)

data Quant(name, var, *args)
data Quant_(name: str, var:str, *args)

data Point(x=0, y=0)
data Point_(x:int=0, y:int=0)

data RadialVector(mag, angle=0)
data RadialVector_(mag:int, angle:int=0)

data ABC(a, b=1, *c)
data ABC_(a:int, b:int=1, *c)

data lenient_2vec(int -> x, int -> y)

# Type-Checking Tests

any_to_ten: -> int = (*args, **kwargs) -> 10
none_to_ten: () -> int = () -> 10

def int_map(f: int->int, xs: int[]) -> int[]: return list(map(f, xs))

def sum_list_range(n: int) -> int =
    range(1, n) |> list |> sum  # type: ignore

# Context managers
def context_produces(out):
    @contextmanager
    def manager():
        yield out
    return manager()

# Where statements
def sum2(ab) = a + b where:
    a, b = ab

# Memoization
import functools

@memoize()
def ridiculously_recursive(n):
    """Requires maxsize=None when called on large numbers."""
    if n <= 0:
        return 1
    result = 0
    for i in range(1, 200):
        result += ridiculously_recursive(n-i)
    return result

@functools.lru_cache(maxsize=None)  # type: ignore
def ridiculously_recursive_(n):
    """Requires maxsize=None when called on large numbers."""
    if n <= 0:
        return 1
    result = 0
    for i in range(1, 200):
        result += ridiculously_recursive_(n-i)
    return result

def fib(n if n < 2) = n

@memoize()  # type: ignore
addpattern def fib(n) = fib(n-1) + fib(n-2)  # type: ignore

@recursive_iterator
def Fibs() = (0, 1) :: map((+), Fibs(), Fibs()$[1:])

fib_ = reiterable(Fibs())$[]

# MapReduce
from collections import defaultdict

join_pairs1 = reduce$((def (acc, (k, v)) ->
    acc[k] += v;
    acc
), ?, defaultdict(list))

def join_pairs2([]) = defaultdict(list)
addpattern def join_pairs2([(k, v)] + tail) =  # type: ignore
    result = join_pairs2(tail)
    result[k] += v
    result


# Match data
match data data1(x)

data data2(int() as x)

match data data3(*xs)

data data4(**kws)

data data5(x, int() as y, str() as z):
    """docstring"""
    attr = 1

class BaseClass

data data6(int() as x) from BaseClass

data namedpt(str() as name, int() as x, int() as y):
    def mag(self) = (self.x**2 + self.y**2)**0.5

data intdata(int(x))
data intdata_(class int(x))


# Descriptor test
def tuplify(*args) = args

class descriptor_test:
    lam = self -> self
    comp = tuplify .. ident

    @recursive_iterator
    def N(self, i=0) =
        [(self, i)] :: self.N(i+1)

    @recursive_iterator
    match def N_(self, *, i=0) =
        [(self, i)] :: self.N_(i=i+1)


# Function named Ad.ef
class Ad:
    ef: typing.Callable

def Ad.ef(self, 0) = 1  # type: ignore
addpattern def Ad.ef(self, x) = x + 1  # type: ignore


# Storage class
class store:
    one = 1
    two = 2
    plus1 = (+)$(1)
    data A(x)


# Locals and globals
def ret_locals() =
    abc = 1
    locals()
def ret_globals() =
    abc = 1
    locals()


# Pos/kwd only args
match def pos_only(a, b, /) = a, b

match def kwd_only(*, a) = a


# Match args classes
class Matchable:
    __match_args__ = ("x", "y", "z")
    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z


# eval_iters

def eval_iters(() :: it) =
    it |> map$(eval_iters) |> list

addpattern def eval_iters(x) = x  # type: ignore


def recursive_map(func, () :: it) =
    it |> map$(recursive_map$(func)) |> func
addpattern def recursive_map(func, x) = func(x)  # type: ignore

def list_it(() :: it) = list(it)
addpattern def list_it(x) = x  # type: ignore

eval_iters_ = recursive_map$(list_it)


# Lazy patterns
def reqs(client):
    yield from client$ (init) (resps(client))
def resps(client):
    yield from server (reqs(client))

def strict_client(init, [resp] :: resps) =
    [init] :: strict_client$ (nxt resp) (resps)
def lazy_client(init, all_resps) =
    [init] :: (def ([resp] :: resps) -> lazy_client$ (nxt resp) (resps))(all_resps)
def lazy_client_(init, all_resps):
    yield init
    yield from lazy_client$ (nxt resp) (resps) where:
        [resp] :: resps = all_resps

def server([req] :: reqs) =
    [process req] :: server reqs

init = 0
def nxt(resp) = resp
def process(req) = req+1


# Metaclass
class Meta(type):
    def __new__(cls, name, bases, namespace, **kwargs):
        namespace.update(kwargs)
        return super(Meta, cls).__new__(cls, name, bases, namespace)
    def __init__(self, *args, **kwargs):
        return super(Meta, self).__init__(*args)  # drop kwargs

# View
def only_match_if(x) = def (==x) -> x

def only_match_int(int() as x) = x

def only_match_abc(x):
    if x == "abc":
        return x
    else:
        raise MatchError()

# yield def
yield def empty_it():
    pass

yield def just_it(x): yield x

yield def empty_it_of_int(int() as x): pass

yield match def just_it_of_int(int() as x):
    yield x

match yield def just_it_of_int_(int() as x):
    yield x

# maximum difference
def maxdiff1(ns) = (
    ns
    |> scan$(min)
    |> zip$(ns)
    |> starmap$(-)
    |> filter$(->_ != 0)
    |> reduce$(max, ?, -1)
)

def S(binop, unop) = lift(binop)(ident, unop)
def ne_zero(x) = x != 0

maxdiff2 = (
    reduce$(max, ?, -1)
    <.. filter$(ne_zero)
    <.. starmap$(-)
    <.. S(zip, scan$(min))
)

maxdiff3 = (
    ident `lift(zip)` scan$(min)  # type: ignore
    ..> starmap$(-)
    ..> filter$(ne_zero)
    ..> reduce$(max, ?, -1)
)

def S_(binop, unop) = x -> binop(x, unop(x))

maxdiff_ = (
    reduce$(max, ?, -1)
    <.. filter$(->_ != 0)
    <.. starmap$(-)
    <.. S_(zip, scan$(min))
)

# matching parens
matching_parens_1 = (
    map$(-> if _ == "(" then 1 else
        if _ == ")" then -1 else 0)
    ..> scan$(+)
    ..> (::)$([0], ?)
    ..> reiterable
    ..> -> min(_) == 0 == _$[-1]
)

def multi_func(*funcs) = (*args, **kwargs) -> (f(*args, **kwargs) for f in funcs)

matching_parens_2 = (
    map$(->
        if _ == "(" then 1 else
        if _ == ")" then -1 else 0
    ) ..> scan$(+)
    ..> (::)$([0], ?)
    ..> reiterable
    ..> multi_func(min, .$[-1])
    ..> map$(.==0)
    ..> all
)

def join_args(*args) = args
multi_func_ = lift(join_args)

matching_parens_3 = (
    map$(
        multi_func_((.=="("), (.==")"))
        ..> zip$((1, -1))
        ..> starmap$(*)
        ..> sum
    ) ..> scan$(+)
    ..> (::)$([0], ?)
    ..> reiterable
    ..> multi_func_(min, .$[-1])
    ..> map$(.==0)
    ..> all
)

matching_parens_4 = (
    map$(
        lift(,)((.=="("), (.==")"))
        ..> zip$((1, -1))
        ..> starmap$(*)
        ..> sum
    ) ..> scan$(+)
    ..> (::)$([0], ?)
    ..> reiterable
    ..> lift(,)(min, .$[-1])
    ..> map$(.==0)
    ..> all
)

# point-free
odd_digits_to_chars = (
    groupsof$(2)
    ..> starmap$(
        (c, x=None) ->
            c + chr(ord(c) + int(x)) if x is not None else c
    )
    ..> "".join
)

truncate_sentence = (
    k ->
    .split( )
    ..> .$[:k]
    ..> " ".join
)

maxcolsum = map$(sum) ..> max

dict_zip = (
    (,)
    ..> map$(.items())
    ..> flatten
    ..> collectby$(.[0], value_func=.[1])
)


# n-ary reduction
def binary_reduce(binop, it) = (
    it
    |> reiterable
    |> lift(zip)(.$[:-1], .$[1:])
    |> starmap$(binop)
)

def nary_reduce(n, op, it) = (
    it
    |> reiterable
    |> lift(zip)(*(.$[i : (i+1-n) or None] for i in range(n)))
    |> starmap$(op)
)

binary_reduce_ = nary_reduce$(2)


# last/end
import operator

def last(n=0 if n >= 0) = -n or None

# TODO: #645 to remove the below type: ignore
data End(offset `isinstance` int = 0 if offset <= 0):  # type: ignore
    def __add__(self, other) =  # type: ignore
        End(self.offset + operator.index(other))
    __radd__ = __add__
    def __sub__(self, other) =
        End(self.offset - operator.index(other))
    def __index__(self if self.offset < 0) = self.offset
    def __call__(self) = self.offset or None

end = End()


# advent of code
proc_moves = (
    .strip()
    ..> .splitlines()
    ..> map$(
        .split()
        ..*> (def (move, num) ->
            n = int(num);
            # (horizontal, vertical)
            (n, 0) if move == "forward" else
            (0, n) if move == "down" else
            (0, -n) if move == "up" else
            (assert)(False)
        )
    )
)

final_pos = (
    proc_moves
    ..*> zip
    ..> map$(sum)
    ..*> (*)
)

final_aim = (
    proc_moves
    ..> reduce$(
        (def ((hpos, vpos, aim), (hmov, amov)) ->
            (hpos + hmov, vpos + hmov * aim, aim + amov)
        ),
        ?,
        (0, 0, 0),
    )
    ..> .[:-1]
    ..*> (*)
)

def gam_eps_rate(bitarr) = (
    bitarr
    |*> zip
    |> map$(map$(int))
    |> map$(sum)
    |> map$(.>len(bitarr)//2)
    |> lift(,)(ident, map$(not))
    |> map$(map$(int))
    |> map$(map$(str))
    |> map$("".join)
    |> map$(int$(?, 2))
    |*> (*)
)

def gam_eps_rate_(bitarr) = (
    bitarr
    |*> zip
    |> map$(
        map$(int)
        ..> sum
        ..> (.>len(bitarr)//2)
    )
    |> lift(,)(ident, map$(not))
    |> map$(
        map$(int ..> str)
        ..> "".join
        ..> int$(?, 2)
    )
    |*> (*)
)


# Search patterns
def first_twin(_ + [p, (.-2) -> p] + _) = (p, p+2)
def first_twin_((*_, p, (.-2) -> p, *_)) = (p, p+2)

def has_abc(s):
    match _ + "abc" + _ in s:
        return True
    else:
        return False

def split1_comma(s):
    match s1 + "," + s2 in s:
        return s1, s2
    else:
        return s, ""

def odd_primes(p=3) =
    (p,) :: filter(-> _ % p != 0, odd_primes(p + 2))

def primes() =
    (2,) :: odd_primes()

def twin_primes(_ :: [p, (.-2) -> p] :: ps) =
    [(p, p+2)] :: twin_primes([p + 2] :: ps)

addpattern def twin_primes() =  # type: ignore
    twin_primes(primes())


# class matching
class HasElems:
    def __init__(self, *elems):
        self.elems = elems

class HasVal:
    def __init__(self, val):
        self.val = val

class HasTwoVals:
    def __init__(self, val1, val2):
        self.val1, self.val2 = val1, val2

class HasThreeVals:
    def __init__(self, val1, val2, val3):
        self.val1, self.val2, self.val3 = val1, val2, val3

match def is_complex_tree(
    HasElems(
        elems=[
            *_,
            _,
            HasVal(
                val=HasThreeVals(
                    val1=[
                        HasTwoVals(
                            val1="a",
                            val2="b",
                        ),
                    ],
                    val2=[],
                    val3=[],
                )
            ),
        ]
    )
) = True
addpattern def is_complex_tree(_) = False  # type: ignore


# Custom multidim arrs
def zeros(shape):
    if not shape:
        return 0
    arr = []
    for _ in range(shape[0]):
        arr.append(zeros(shape[1:]))
    return arr

def indices(shape):
    if not shape:
        return [()]
    inds = []
    for i in range(shape[0]):
        for ind in indices(shape[1:]):
            inds.append((i,) + ind)
    return inds

def getind(arr, ind):
    if not ind:
        return arr
    return getind(arr[ind[0]], ind[1:])

def setind(arr, ind, val):
    if not ind:
        return val
    arr[ind[0]] = setind(arr[ind[0]], ind[1:], val)
    return arr

data Arr(shape, arr):
    @property  # type: ignore
    def ndim(self) = len(self.shape)
    def reshape(self, new_shape):
        assert product(self.shape) == product(new_shape), (self.shape, new_shape)
        new_arr = zeros(new_shape)
        for old_ind, new_ind in zip(indices(self.shape), indices(new_shape), strict=True):
            setind(new_arr, new_ind, getind(self.arr, old_ind))
        return self.__class__(new_shape, new_arr)
    @classmethod
    def __matconcat__(cls, arrs, axis):
        assert all(arr.shape[:axis] + arr.shape[axis:] == arrs[0].shape[:axis] + arrs[0].shape[axis:] for arr in arrs), (arrs, axis)
        new_shape = arrs[0].shape[:axis] + (sum(arr.shape[axis] for arr in arrs),) + arrs[0].shape[axis+1:]
        new_arr = zeros(new_shape)
        for i, arr in enumerate(arrs):
            for ind in indices(arr.shape):
                setind(
                    new_arr,
                    ind[:axis] + (
                        ind[axis] + sum(arr.shape[axis] for arr in arrs[:i]),
                    ) + ind[axis+1:],
                    getind(arr.arr, ind),
                )
        return cls(new_shape, new_arr)
    def __fmap__(self, func):
        new_arr = zeros(self.shape)
        for ind in indices(self.shape):
            setind(new_arr, ind, func(getind(self.arr, ind)))
        return self.__class__(self.shape, new_arr)
    def __neg__(self) = self |> fmap$(-)
